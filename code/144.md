


# 144. 最长异或值路径 :

首先 ： 求xor 最大我们可以用 **Trie** 树来完成<br/>
假设0是root 以及我们知道0到任何点的xor值 <br/>
任意两点 **(u,v)** 的xor值等于 =  **xor(root,u) ^ xor(root,v)** => 因为a^a=0, 跟要到达u v 的公共祖先，可抵消




```
// Don't place your source in a package
import java.text.DecimalFormat;
import java.util.*;
import java.lang.*;
import java.io.*;
import java.math.*;








// Please name your class Main
public class Main {
    static FastScanner fs=new FastScanner();
    static class FastScanner {//scanner from SecondThread
        BufferedReader br=new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st=new StringTokenizer("");
        public String next() {
            while (!st.hasMoreElements())
                try {
                    st=new StringTokenizer(br.readLine());
                } catch (IOException e) {
                    e.printStackTrace();
                }
            return st.nextToken();
        }
        int Int() {
            return Integer.parseInt(next());
        }

        long Long() {
            return Long.parseLong(next());
        }

        String Str(){
            return next();
        }
    }


    public static void main (String[] args) throws java.lang.Exception {
        PrintWriter out = new PrintWriter(System.out);
        int T=1;
        for(int t=0;t<T;t++){
            int n=Int();
            int A[][]=new int[n-1][3];
            for(int i=0;i<n-1;i++){
                A[i][0]=Int();
                A[i][1]=Int();
                A[i][2]=Int();
            }

            Sol sol=new Sol();
            sol.solution(out,A);
        }
        out.flush();

    }

    public static int Int(){
        return fs.Int();
    }
    public static long Long(){
        return fs.Long();
    }
    public static String Str(){
        return fs.Str();
    }

}



class Sol{
    List<int[]>g[];
    int res=0;
    Node trie[]=new Node[2];
    boolean visit[];
    int val=0;
    int dis[];
    public void solution(PrintWriter out,int A[][]){
        int n=A.length+1;
        visit=new boolean[n];
        dis=new int[n];
        g=new ArrayList[n];
        for(int i=0;i<n;i++){
            g[i]=new ArrayList<>();
        }

        for(int p[]:A){
            int u=p[0],v=p[1],w=p[2];
            g[u].add(new int[]{v,w});
            g[v].add(new int[]{u,w});
        }

        visit[0]=true;
        insert(trie,0,31,1);
        dfs(trie,0,0);



        for(int i=0;i<dis.length;i++){
            val=0;
            search(trie,dis[i],31);
            res=Math.max(res,val^dis[i]);
        }

        out.println(res);
    }

    public void dfs(Node trie[],int root,int prexor){

        List<int[]>childs=g[root];
        for(int next[]:childs){
            int u=next[0],w=next[1];
            if(visit[u])continue;
            int xor=w^prexor;
            visit[u]=true;
            dis[u]=xor;
            insert(trie,xor,31,1);
            dfs(trie,u,xor);

        }
    }

    public void search(Node trie[],int num,int i){
        if(i<0)return;

        int bit=num&(1<<i);
        if(bit==0){
            if(trie[1]!=null&&trie[1].cnt>0){
                val=val|(1<<i);
                search(trie[1].childs,num,i-1);
            }
            else{
                search(trie[0].childs,num,i-1);
            }
        }
        else{
            if(trie[0]!=null&&trie[0].cnt>0){
                search(trie[0].childs,num,i-1);
            }
            else{
                val=val|(1<<i);
                search(trie[1].childs,num,i-1);
            }
        }

    }

    public void insert(Node trie[],int num,int i,int cnt){
        if(i<0)return;
        int bit=num&(1<<i);
        if(bit!=0){
            if(trie[1]==null)trie[1]=new Node();
            trie[1].cnt+=cnt;
            insert(trie[1].childs,num,i-1,cnt);
        }
        else{
            if(trie[0]==null)trie[0]=new Node();
            trie[0].cnt+=cnt;
            insert(trie[0].childs,num,i-1,cnt);
        }
    }

    class Node{
        int cnt=0;
        Node childs[]=new Node[2];
    }
}




```
   

